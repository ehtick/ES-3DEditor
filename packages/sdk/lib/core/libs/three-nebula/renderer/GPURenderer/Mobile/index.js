import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { ParticleBuffer, Target, TextureAtlas, UniqueList } from '../common';
import { fragmentShader, vertexShader } from './shaders';
import BaseRenderer from '../../BaseRenderer';
import { DEFAULT_RENDERER_OPTIONS } from '../common/constants';
import { Pool } from '../../../core';
import { RENDERER_TYPE_GPU_MOBILE } from '../../types';
let THREE;
/**
 * GPURenderer for mobile devices that do not support floating point textures.
 *
 * @author thrax <manthrax@gmail.com>
 * @author rohan-deshpande <rohan@creativelifeform.com>
 */

export default class MobileGPURenderer extends BaseRenderer {
  constructor(container, three, options = DEFAULT_RENDERER_OPTIONS) {
    super(RENDERER_TYPE_GPU_MOBILE);
    THREE = this.three = three;

    const props = _objectSpread(_objectSpread({}, DEFAULT_RENDERER_OPTIONS), options);

    const {
      camera,
      maxParticles,
      baseColor,
      blending,
      depthTest,
      depthWrite,
      transparent,
      shouldDebugTextureAtlas
    } = props;
    const particleBuffer = new ParticleBuffer(maxParticles, THREE);
    const material = new THREE.ShaderMaterial({
      uniforms: {
        baseColor: {
          value: new THREE.Color(baseColor)
        },
        uTexture: {
          value: null
        },
        FFatlasIndex: {
          value: null
        },
        atlasDim: {
          value: new THREE.Vector2()
        }
      },
      vertexShader: vertexShader(),
      fragmentShader: fragmentShader(),
      blending: THREE[blending],
      depthTest,
      depthWrite,
      transparent
    });
    this.camera = camera;
    this.targetPool = new Pool();
    this.uniqueList = new UniqueList(maxParticles);
    this.particleBuffer = particleBuffer;
    this.buffer = particleBuffer.buffer;
    this.stride = particleBuffer.stride;
    this.geometry = particleBuffer.geometry;
    this.material = material;
    this.points = new THREE.Points(this.geometry, this.material);
    this.points.frustumCulled = false;
    this.shouldDebugTextureAtlas = shouldDebugTextureAtlas;
    container.add(this.points);
  }

  onSystemUpdate(system) {
    super.onSystemUpdate(system);
    this.buffer.needsUpdate = true;
    const {
      textureAtlas
    } = this;

    if (textureAtlas) {
      textureAtlas.update();
      this.material.uniforms.atlasDim.value.set(textureAtlas.atlasTexture.image.width, textureAtlas.atlasTexture.image.height);
    }
  }
  /**
   * Pools the particle target if it does not exist.
   * Updates the target and maps particle properties to the point.
   *
   * @param {Particle}
   */


  onParticleCreated(particle) {
    if (!particle.target) {
      particle.target = this.targetPool.get(Target, THREE);
      this.uniqueList.add(particle.id);
    }

    this.updateTarget(particle).mapParticleTargetPropsToPoint(particle);
  }
  /**
   * Maps particle properties to the point if the particle has a target.
   *
   * @param {Particle}
   */


  onParticleUpdate(particle) {
    if (!particle.target) {
      return;
    }

    this.updateTarget(particle).mapParticleTargetPropsToPoint(particle);
  }
  /**
   * Resets and clears the particle target.
   *
   * @param {Particle}
   */


  onParticleDead(particle) {
    if (!particle.target) {
      return;
    }

    particle.target.reset();
    this.mapParticleTargetPropsToPoint(particle);
    particle.target = null;
  }
  /**
   * Maps all mutable properties from the particle to the target.
   *
   * @param {Particle}
   * @return {GPURenderer}
   */


  updateTarget(particle) {
    const {
      position,
      rotation,
      scale,
      radius,
      color,
      alpha,
      body,
      id
    } = particle;
    const {
      r,
      g,
      b
    } = color;
    particle.target.position.copy(position);
    particle.target.rotation.copy(rotation);
    particle.target.size = scale * radius;
    particle.target.color.setRGB(r, g, b);
    particle.target.alpha = alpha;
    particle.target.index = this.uniqueList.find(id);

    if (body && body instanceof THREE.Sprite) {
      const {
        map
      } = body.material;
      particle.target.texture = map;
      particle.target.textureIndex = this.getTextureID(map, this.shouldDebugTextureAtlas);
    }

    return this;
  }
  /**
   * Entry point for mapping particle properties to buffer geometry points.
   *
   * @param {Particle} particle - The particle containing the properties to map
   * @return {GPURenderer}
   */


  mapParticleTargetPropsToPoint(particle) {
    this.updatePointPosition(particle).updatePointSize(particle).updatePointRotation(particle).updatePointColor(particle).updatePointAlpha(particle).updatePointTextureIndex(particle);
    return this;
  }
  /**
   * Updates the point's position according to the particle's target position.
   *
   * @param {Particle} particle - The particle containing the target position.
   * @return {GPURenderer}
   */


  updatePointPosition(particle) {
    const attribute = 'position';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    buffer.array[target.index * stride + offset + 0] = target.position.x;
    buffer.array[target.index * stride + offset + 1] = target.position.y;
    buffer.array[target.index * stride + offset + 2] = target.position.z;
    return this;
  }
  /**
   * Updates the point's size relative to the particle's target scale and radius.
   *
   * @param {Particle} particle - The particle containing the target scale.
   * @return {GPURenderer}
   */


  updatePointSize(particle) {
    const attribute = 'size';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    buffer.array[target.index * stride + offset + 0] = target.size;
    return this;
  }
  /**
   * Updates the point's rotation.
   *
   * @param {Particle} particle - The particle containing the target rotation.
   * @return {GPURenderer}
   */


  updatePointRotation(particle) {
    const attribute = 'rotation';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    buffer.array[target.index * stride + offset + 0] = target.rotation.z;
    return this;
  }
  /**
   * Updates the point's color attribute according with the particle's target color.
   *
   * @param {Particle} particle - The particle containing the target color and alpha.
   * @return {GPURenderer}
   */


  updatePointColor(particle) {
    const attribute = 'color';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    buffer.array[target.index * stride + offset + 0] = target.color.r;
    buffer.array[target.index * stride + offset + 1] = target.color.g;
    buffer.array[target.index * stride + offset + 2] = target.color.b;
    return this;
  }
  /**
   * Updates the point alpha attribute with the particle's target alpha.
   *
   * @param {Particle} particle - The particle containing the target alpha.
   * @return {GPURenderer}
   */


  updatePointAlpha(particle) {
    const attribute = 'alpha';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    buffer.array[target.index * stride + offset + 0] = target.alpha;
    return this;
  }
  /**
   * Updates the point texture attribute with the particle's target texture.
   *
   * @param {Particle} particle - The particle containing the target texture.
   * @return {GPURenderer}
   */


  updatePointTextureIndex(particle) {
    const attribute = 'texID';
    const {
      geometry,
      stride,
      buffer
    } = this;
    const {
      target
    } = particle;
    const {
      offset
    } = geometry.attributes[attribute];
    const id = target.index * stride + offset + 0; // eslint-disable-next-line

    if (false) {
      buffer.array[id] = target.textureIndex;
    } else {
      let ti = target.textureIndex * 4;
      const ta = this.textureAtlas;
      const ida = ta.indexData;
      const nx = ida[ti++];
      const ny = ida[ti++];
      const px = ida[ti++];
      const py = ida[ti++];
      buffer.array[id] = (nx * ta.atlasTexture.image.width | 0) + px;
      buffer.array[id + 1] = (ny * ta.atlasTexture.image.height | 0) + py;
    }

    return this;
  }

  getTextureID(texture, debug) {
    if (texture.textureIndex === undefined) {
      if (!this.textureAtlas) {
        this.textureAtlas = new TextureAtlas(this, debug);
      }

      this.textureAtlas.addTexture(texture);
    }

    return texture.textureIndex;
  }

  destroy() {
    const {
      container,
      points,
      textureAtlas,
      uniqueList
    } = this;
    container.remove(points);
    uniqueList.destroy();
    textureAtlas && textureAtlas.destroy();
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9yZW5kZXJlci9HUFVSZW5kZXJlci9Nb2JpbGUvaW5kZXguanMiXSwibmFtZXMiOlsiUGFydGljbGVCdWZmZXIiLCJUYXJnZXQiLCJUZXh0dXJlQXRsYXMiLCJVbmlxdWVMaXN0IiwiZnJhZ21lbnRTaGFkZXIiLCJ2ZXJ0ZXhTaGFkZXIiLCJCYXNlUmVuZGVyZXIiLCJERUZBVUxUX1JFTkRFUkVSX09QVElPTlMiLCJQb29sIiwiUkVOREVSRVJfVFlQRV9HUFVfTU9CSUxFIiwiVEhSRUUiLCJNb2JpbGVHUFVSZW5kZXJlciIsImNvbnN0cnVjdG9yIiwiY29udGFpbmVyIiwidGhyZWUiLCJvcHRpb25zIiwicHJvcHMiLCJjYW1lcmEiLCJtYXhQYXJ0aWNsZXMiLCJiYXNlQ29sb3IiLCJibGVuZGluZyIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJ0cmFuc3BhcmVudCIsInNob3VsZERlYnVnVGV4dHVyZUF0bGFzIiwicGFydGljbGVCdWZmZXIiLCJtYXRlcmlhbCIsIlNoYWRlck1hdGVyaWFsIiwidW5pZm9ybXMiLCJ2YWx1ZSIsIkNvbG9yIiwidVRleHR1cmUiLCJGRmF0bGFzSW5kZXgiLCJhdGxhc0RpbSIsIlZlY3RvcjIiLCJ0YXJnZXRQb29sIiwidW5pcXVlTGlzdCIsImJ1ZmZlciIsInN0cmlkZSIsImdlb21ldHJ5IiwicG9pbnRzIiwiUG9pbnRzIiwiZnJ1c3R1bUN1bGxlZCIsImFkZCIsIm9uU3lzdGVtVXBkYXRlIiwic3lzdGVtIiwibmVlZHNVcGRhdGUiLCJ0ZXh0dXJlQXRsYXMiLCJ1cGRhdGUiLCJzZXQiLCJhdGxhc1RleHR1cmUiLCJpbWFnZSIsIndpZHRoIiwiaGVpZ2h0Iiwib25QYXJ0aWNsZUNyZWF0ZWQiLCJwYXJ0aWNsZSIsInRhcmdldCIsImdldCIsImlkIiwidXBkYXRlVGFyZ2V0IiwibWFwUGFydGljbGVUYXJnZXRQcm9wc1RvUG9pbnQiLCJvblBhcnRpY2xlVXBkYXRlIiwib25QYXJ0aWNsZURlYWQiLCJyZXNldCIsInBvc2l0aW9uIiwicm90YXRpb24iLCJzY2FsZSIsInJhZGl1cyIsImNvbG9yIiwiYWxwaGEiLCJib2R5IiwiciIsImciLCJiIiwiY29weSIsInNpemUiLCJzZXRSR0IiLCJpbmRleCIsImZpbmQiLCJTcHJpdGUiLCJtYXAiLCJ0ZXh0dXJlIiwidGV4dHVyZUluZGV4IiwiZ2V0VGV4dHVyZUlEIiwidXBkYXRlUG9pbnRQb3NpdGlvbiIsInVwZGF0ZVBvaW50U2l6ZSIsInVwZGF0ZVBvaW50Um90YXRpb24iLCJ1cGRhdGVQb2ludENvbG9yIiwidXBkYXRlUG9pbnRBbHBoYSIsInVwZGF0ZVBvaW50VGV4dHVyZUluZGV4IiwiYXR0cmlidXRlIiwib2Zmc2V0IiwiYXR0cmlidXRlcyIsImFycmF5IiwieCIsInkiLCJ6IiwidGkiLCJ0YSIsImlkYSIsImluZGV4RGF0YSIsIm54IiwibnkiLCJweCIsInB5IiwiZGVidWciLCJ1bmRlZmluZWQiLCJhZGRUZXh0dXJlIiwiZGVzdHJveSIsInJlbW92ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBU0EsY0FBVCxFQUF5QkMsTUFBekIsRUFBaUNDLFlBQWpDLEVBQStDQyxVQUEvQyxRQUFpRSxXQUFqRTtBQUNBLFNBQVNDLGNBQVQsRUFBeUJDLFlBQXpCLFFBQTZDLFdBQTdDO0FBRUEsT0FBT0MsWUFBUCxNQUF5QixvQkFBekI7QUFDQSxTQUFTQyx3QkFBVCxRQUF5QyxxQkFBekM7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGVBQXJCO0FBQ0EsU0FBU0Msd0JBQVQsUUFBeUMsYUFBekM7QUFFQSxJQUFJQyxLQUFKO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGVBQWUsTUFBTUMsaUJBQU4sU0FBZ0NMLFlBQWhDLENBQTZDO0FBQzFETSxFQUFBQSxXQUFXLENBQUNDLFNBQUQsRUFBWUMsS0FBWixFQUFtQkMsT0FBTyxHQUFHUix3QkFBN0IsRUFBdUQ7QUFDaEUsVUFBTUUsd0JBQU47QUFFQUMsSUFBQUEsS0FBSyxHQUFH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IFVuaXF1ZUxpc3QgfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHsgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciB9IGZyb20gJy4vc2hhZGVycyc7XG5cbmltcG9ydCBCYXNlUmVuZGVyZXIgZnJvbSAnLi4vLi4vQmFzZVJlbmRlcmVyJztcbmltcG9ydCB7IERFRkFVTFRfUkVOREVSRVJfT1BUSU9OUyB9IGZyb20gJy4uL2NvbW1vbi9jb25zdGFudHMnO1xuaW1wb3J0IHsgUG9vbCB9IGZyb20gJy4uLy4uLy4uL2NvcmUnO1xuaW1wb3J0IHsgUkVOREVSRVJfVFlQRV9HUFVfTU9CSUxFIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5sZXQgVEhSRUU7XG5cbi8qKlxuICogR1BVUmVuZGVyZXIgZm9yIG1vYmlsZSBkZXZpY2VzIHRoYXQgZG8gbm90IHN1cHBvcnQgZmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMuXG4gKlxuICogQGF1dGhvciB0aHJheCA8bWFudGhyYXhAZ21haWwuY29tPlxuICogQGF1dGhvciByb2hhbi1kZXNocGFuZGUgPHJvaGFuQGNyZWF0aXZlbGlmZWZvcm0uY29tPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2JpbGVHUFVSZW5kZXJlciBleHRlbmRzIEJhc2VSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdGhyZWUsIG9wdGlvbnMgPSBERUZBVUxUX1JFTkRFUkVSX09QVElPTlMpIHtcbiAgICBzdXBlcihSRU5ERVJFUl9UWVBFX0dQVV9NT0JJTEUpO1xuXG4gICAgVEhSRUUgPSB0aGlzLnRocmVlID0gdGhyZWU7XG4gICAgY29uc3QgcHJvcHMgPSB7IC4uLkRFRkFVTFRfUkVOREVSRVJfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIG1heFBhcnRpY2xlcyxcbiAgICAgIGJhc2VDb2xvcixcbiAgICAgIGJsZW5kaW5nLFxuICAgICAgZGVwdGhUZXN0LFxuICAgICAgZGVwdGhXcml0ZSxcbiAgICAgIHRyYW5zcGFyZW50LFxuICAgICAgc2hvdWxkRGVidWdUZXh0dXJlQXRsYXMsXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBhcnRpY2xlQnVmZmVyID0gbmV3IFBhcnRpY2xlQnVmZmVyKG1heFBhcnRpY2xlcywgVEhSRUUpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGJhc2VDb2xvcjogeyB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKGJhc2VDb2xvcikgfSxcbiAgICAgICAgdVRleHR1cmU6IHsgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgRkZhdGxhc0luZGV4OiB7IHZhbHVlOiBudWxsIH0sXG4gICAgICAgIGF0bGFzRGltOiB7IHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpIH0sXG4gICAgICB9LFxuICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIoKSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlcigpLFxuICAgICAgYmxlbmRpbmc6IFRIUkVFW2JsZW5kaW5nXSxcbiAgICAgIGRlcHRoVGVzdCxcbiAgICAgIGRlcHRoV3JpdGUsXG4gICAgICB0cmFuc3BhcmVudCxcbiAgICB9KTtcblxuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMudGFyZ2V0UG9vbCA9IG5ldyBQb29sKCk7XG4gICAgdGhpcy51bmlxdWVMaXN0ID0gbmV3IFVuaXF1ZUxpc3QobWF4UGFydGljbGVzKTtcbiAgICB0aGlzLnBhcnRpY2xlQnVmZmVyID0gcGFydGljbGVCdWZmZXI7XG4gICAgdGhpcy5idWZmZXIgPSBwYXJ0aWNsZUJ1ZmZlci5idWZmZXI7XG4gICAgdGhpcy5zdHJpZGUgPSBwYXJ0aWNsZUJ1ZmZlci5zdHJpZGU7XG4gICAgdGhpcy5nZW9tZXRyeSA9IHBhcnRpY2xlQnVmZmVyLmdlb21ldHJ5O1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLnBvaW50cyA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5wb2ludHMuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2hvdWxkRGVidWdUZXh0dXJlQXRsYXMgPSBzaG91bGREZWJ1Z1RleHR1cmVBdGxhcztcblxuICAgIGNvbnRhaW5lci5hZGQodGhpcy5wb2ludHMpO1xuICB9XG5cbiAgb25TeXN0ZW1VcGRhdGUoc3lzdGVtKSB7XG4gICAgc3VwZXIub25TeXN0ZW1VcGRhdGUoc3lzdGVtKTtcblxuICAgIHRoaXMuYnVmZmVyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIGNvbnN0IHsgdGV4dHVyZUF0bGFzIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRleHR1cmVBdGxhcykge1xuICAgICAgdGV4dHVyZUF0bGFzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5hdGxhc0RpbS52YWx1ZS5zZXQoXG4gICAgICAgIHRleHR1cmVBdGxhcy5hdGxhc1RleHR1cmUuaW1hZ2Uud2lkdGgsXG4gICAgICAgIHRleHR1cmVBdGxhcy5hdGxhc1RleHR1cmUuaW1hZ2UuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQb29scyB0aGUgcGFydGljbGUgdGFyZ2V0IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKiBVcGRhdGVzIHRoZSB0YXJnZXQgYW5kIG1hcHMgcGFydGljbGUgcHJvcGVydGllcyB0byB0aGUgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFydGljbGV9XG4gICAqL1xuICBvblBhcnRpY2xlQ3JlYXRlZChwYXJ0aWNsZSkge1xuICAgIGlmICghcGFydGljbGUudGFyZ2V0KSB7XG4gICAgICBwYXJ0aWNsZS50YXJnZXQgPSB0aGlzLnRhcmdldFBvb2wuZ2V0KFRhcmdldCwgVEhSRUUpO1xuICAgICAgdGhpcy51bmlxdWVMaXN0LmFkZChwYXJ0aWNsZS5pZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUYXJnZXQocGFydGljbGUpLm1hcFBhcnRpY2xlVGFyZ2V0UHJvcHNUb1BvaW50KHBhcnRpY2xlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIHBhcnRpY2xlIHByb3BlcnRpZXMgdG8gdGhlIHBvaW50IGlmIHRoZSBwYXJ0aWNsZSBoYXMgYSB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFydGljbGV9XG4gICAqL1xuICBvblBhcnRpY2xlVXBkYXRlKHBhcnRpY2xlKSB7XG4gICAgaWYgKCFwYXJ0aWNsZS50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRhcmdldChwYXJ0aWNsZSkubWFwUGFydGljbGVUYXJnZXRQcm9wc1RvUG9pbnQocGFydGljbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBhbmQgY2xlYXJzIHRoZSBwYXJ0aWNsZSB0YXJnZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGFydGljbGV9XG4gICAqL1xuICBvblBhcnRpY2xlRGVhZChwYXJ0aWNsZSkge1xuICAgIGlmICghcGFydGljbGUudGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFydGljbGUudGFyZ2V0LnJlc2V0KCk7XG4gICAgdGhpcy5tYXBQYXJ0aWNsZVRhcmdldFByb3BzVG9Qb2ludChwYXJ0aWNsZSk7XG5cbiAgICBwYXJ0aWNsZS50YXJnZXQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcHMgYWxsIG11dGFibGUgcHJvcGVydGllcyBmcm9tIHRoZSBwYXJ0aWNsZSB0byB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfVxuICAgKiBAcmV0dXJuIHtHUFVSZW5kZXJlcn1cbiAgICovXG4gIHVwZGF0ZVRhcmdldChwYXJ0aWNsZSkge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSwgcmFkaXVzLCBjb2xvciwgYWxwaGEsIGJvZHksIGlkIH0gPSBwYXJ0aWNsZTtcbiAgICBjb25zdCB7IHIsIGcsIGIgfSA9IGNvbG9yO1xuXG4gICAgcGFydGljbGUudGFyZ2V0LnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHBhcnRpY2xlLnRhcmdldC5yb3RhdGlvbi5jb3B5KHJvdGF0aW9uKTtcbiAgICBwYXJ0aWNsZS50YXJnZXQuc2l6ZSA9IHNjYWxlICogcmFkaXVzO1xuICAgIHBhcnRpY2xlLnRhcmdldC5jb2xvci5zZXRSR0IociwgZywgYik7XG4gICAgcGFydGljbGUudGFyZ2V0LmFscGhhID0gYWxwaGE7XG4gICAgcGFydGljbGUudGFyZ2V0LmluZGV4ID0gdGhpcy51bmlxdWVMaXN0LmZpbmQoaWQpO1xuXG4gICAgaWYgKGJvZHkgJiYgYm9keSBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSkge1xuICAgICAgY29uc3QgeyBtYXAgfSA9IGJvZHkubWF0ZXJpYWw7XG5cbiAgICAgIHBhcnRpY2xlLnRhcmdldC50ZXh0dXJlID0gbWFwO1xuICAgICAgcGFydGljbGUudGFyZ2V0LnRleHR1cmVJbmRleCA9IHRoaXMuZ2V0VGV4dHVyZUlEKFxuICAgICAgICBtYXAsXG4gICAgICAgIHRoaXMuc2hvdWxkRGVidWdUZXh0dXJlQXRsYXNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRW50cnkgcG9pbnQgZm9yIG1hcHBpbmcgcGFydGljbGUgcHJvcGVydGllcyB0byBidWZmZXIgZ2VvbWV0cnkgcG9pbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSAtIFRoZSBwYXJ0aWNsZSBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIHRvIG1hcFxuICAgKiBAcmV0dXJuIHtHUFVSZW5kZXJlcn1cbiAgICovXG4gIG1hcFBhcnRpY2xlVGFyZ2V0UHJvcHNUb1BvaW50KHBhcnRpY2xlKSB7XG4gICAgdGhpcy51cGRhdGVQb2ludFBvc2l0aW9uKHBhcnRpY2xlKVxuICAgICAgLnVwZGF0ZVBvaW50U2l6ZShwYXJ0aWNsZSlcbiAgICAgIC51cGRhdGVQb2ludFJvdGF0aW9uKHBhcnRpY2xlKVxuICAgICAgLnVwZGF0ZVBvaW50Q29sb3IocGFydGljbGUpXG4gICAgICAudXBkYXRlUG9pbnRBbHBoYShwYXJ0aWNsZSlcbiAgICAgIC51cGRhdGVQb2ludFRleHR1cmVJbmRleChwYXJ0aWNsZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb2ludCdzIHBvc2l0aW9uIGFjY29yZGluZyB0byB0aGUgcGFydGljbGUncyB0YXJnZXQgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UGFydGljbGV9IHBhcnRpY2xlIC0gVGhlIHBhcnRpY2xlIGNvbnRhaW5pbmcgdGhlIHRhcmdldCBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7R1BVUmVuZGVyZXJ9XG4gICAqL1xuICB1cGRhdGVQb2ludFBvc2l0aW9uKHBhcnRpY2xlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gJ3Bvc2l0aW9uJztcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBzdHJpZGUsIGJ1ZmZlciB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gcGFydGljbGU7XG4gICAgY29uc3QgeyBvZmZzZXQgfSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcblxuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAwXSA9IHRhcmdldC5wb3NpdGlvbi54O1xuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAxXSA9IHRhcmdldC5wb3NpdGlvbi55O1xuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAyXSA9IHRhcmdldC5wb3NpdGlvbi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9pbnQncyBzaXplIHJlbGF0aXZlIHRvIHRoZSBwYXJ0aWNsZSdzIHRhcmdldCBzY2FsZSBhbmQgcmFkaXVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSAtIFRoZSBwYXJ0aWNsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgc2NhbGUuXG4gICAqIEByZXR1cm4ge0dQVVJlbmRlcmVyfVxuICAgKi9cbiAgdXBkYXRlUG9pbnRTaXplKHBhcnRpY2xlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gJ3NpemUnO1xuICAgIGNvbnN0IHsgZ2VvbWV0cnksIHN0cmlkZSwgYnVmZmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBwYXJ0aWNsZTtcbiAgICBjb25zdCB7IG9mZnNldCB9ID0gZ2VvbWV0cnkuYXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuXG4gICAgYnVmZmVyLmFycmF5W3RhcmdldC5pbmRleCAqIHN0cmlkZSArIG9mZnNldCArIDBdID0gdGFyZ2V0LnNpemU7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb2ludCdzIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSAtIFRoZSBwYXJ0aWNsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgcm90YXRpb24uXG4gICAqIEByZXR1cm4ge0dQVVJlbmRlcmVyfVxuICAgKi9cbiAgdXBkYXRlUG9pbnRSb3RhdGlvbihwYXJ0aWNsZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9ICdyb3RhdGlvbic7XG4gICAgY29uc3QgeyBnZW9tZXRyeSwgc3RyaWRlLCBidWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHBhcnRpY2xlO1xuICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG5cbiAgICBidWZmZXIuYXJyYXlbdGFyZ2V0LmluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICsgMF0gPSB0YXJnZXQucm90YXRpb24uejtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBvaW50J3MgY29sb3IgYXR0cmlidXRlIGFjY29yZGluZyB3aXRoIHRoZSBwYXJ0aWNsZSdzIHRhcmdldCBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWNsZX0gcGFydGljbGUgLSBUaGUgcGFydGljbGUgY29udGFpbmluZyB0aGUgdGFyZ2V0IGNvbG9yIGFuZCBhbHBoYS5cbiAgICogQHJldHVybiB7R1BVUmVuZGVyZXJ9XG4gICAqL1xuICB1cGRhdGVQb2ludENvbG9yKHBhcnRpY2xlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gJ2NvbG9yJztcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBzdHJpZGUsIGJ1ZmZlciB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gcGFydGljbGU7XG4gICAgY29uc3QgeyBvZmZzZXQgfSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcblxuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAwXSA9IHRhcmdldC5jb2xvci5yO1xuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAxXSA9IHRhcmdldC5jb2xvci5nO1xuICAgIGJ1ZmZlci5hcnJheVt0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAyXSA9IHRhcmdldC5jb2xvci5iO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9pbnQgYWxwaGEgYXR0cmlidXRlIHdpdGggdGhlIHBhcnRpY2xlJ3MgdGFyZ2V0IGFscGhhLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSAtIFRoZSBwYXJ0aWNsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgYWxwaGEuXG4gICAqIEByZXR1cm4ge0dQVVJlbmRlcmVyfVxuICAgKi9cbiAgdXBkYXRlUG9pbnRBbHBoYShwYXJ0aWNsZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9ICdhbHBoYSc7XG4gICAgY29uc3QgeyBnZW9tZXRyeSwgc3RyaWRlLCBidWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHBhcnRpY2xlO1xuICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG5cbiAgICBidWZmZXIuYXJyYXlbdGFyZ2V0LmluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICsgMF0gPSB0YXJnZXQuYWxwaGE7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb2ludCB0ZXh0dXJlIGF0dHJpYnV0ZSB3aXRoIHRoZSBwYXJ0aWNsZSdzIHRhcmdldCB0ZXh0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSAtIFRoZSBwYXJ0aWNsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgdGV4dHVyZS5cbiAgICogQHJldHVybiB7R1BVUmVuZGVyZXJ9XG4gICAqL1xuICB1cGRhdGVQb2ludFRleHR1cmVJbmRleChwYXJ0aWNsZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9ICd0ZXhJRCc7XG4gICAgY29uc3QgeyBnZW9tZXRyeSwgc3RyaWRlLCBidWZmZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IHBhcnRpY2xlO1xuICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgY29uc3QgaWQgPSB0YXJnZXQuaW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKyAwO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBidWZmZXIuYXJyYXlbaWRdID0gdGFyZ2V0LnRleHR1cmVJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRpID0gdGFyZ2V0LnRleHR1cmVJbmRleCAqIDQ7XG4gICAgICBjb25zdCB0YSA9IHRoaXMudGV4dHVyZUF0bGFzO1xuICAgICAgY29uc3QgaWRhID0gdGEuaW5kZXhEYXRhO1xuICAgICAgY29uc3QgbnggPSBpZGFbdGkrK107XG4gICAgICBjb25zdCBueSA9IGlkYVt0aSsrXTtcbiAgICAgIGNvbnN0IHB4ID0gaWRhW3RpKytdO1xuICAgICAgY29uc3QgcHkgPSBpZGFbdGkrK107XG5cbiAgICAgIGJ1ZmZlci5hcnJheVtpZF0gPSAoKG54ICogdGEuYXRsYXNUZXh0dXJlLmltYWdlLndpZHRoKSB8IDApICsgcHg7XG4gICAgICBidWZmZXIuYXJyYXlbaWQgKyAxXSA9ICgobnkgKiB0YS5hdGxhc1RleHR1cmUuaW1hZ2UuaGVpZ2h0KSB8IDApICsgcHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRUZXh0dXJlSUQodGV4dHVyZSwgZGVidWcpIHtcbiAgICBpZiAodGV4dHVyZS50ZXh0dXJlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCF0aGlzLnRleHR1cmVBdGxhcykge1xuICAgICAgICB0aGlzLnRleHR1cmVBdGxhcyA9IG5ldyBUZXh0dXJlQXRsYXModGhpcywgZGVidWcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRleHR1cmVBdGxhcy5hZGRUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlLnRleHR1cmVJbmRleDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgeyBjb250YWluZXIsIHBvaW50cywgdGV4dHVyZUF0bGFzLCB1bmlxdWVMaXN0IH0gPSB0aGlzO1xuXG4gICAgY29udGFpbmVyLnJlbW92ZShwb2ludHMpO1xuICAgIHVuaXF1ZUxpc3QuZGVzdHJveSgpO1xuICAgIHRleHR1cmVBdGxhcyAmJiB0ZXh0dXJlQXRsYXMuZGVzdHJveSgpO1xuICB9XG59XG4iXX0=